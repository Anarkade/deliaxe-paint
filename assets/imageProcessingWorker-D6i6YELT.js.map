{"version":3,"file":"imageProcessingWorker-D6i6YELT.js","sources":["../src/lib/colorQuantization.ts","../src/workers/imageProcessingWorker.ts"],"sourcesContent":["// Color quantization utilities for retro palette conversion\n\nexport interface Color {\n  r: number;\n  g: number;\n  b: number;\n  count?: number;\n}\n\n/**\n * Convert RGB color to RGB 3-3-3 format (Mega Drive format)\n */\nexport const toRGB333 = (r: number, g: number, b: number): Color => {\n  // Convert 8-bit values to 3-bit values\n  const r3bit = Math.round((r / 255) * 7);\n  const g3bit = Math.round((g / 255) * 7);\n  const b3bit = Math.round((b / 255) * 7);\n  \n  // Convert back to 8-bit values for display\n  return {\n    r: Math.round((r3bit / 7) * 255),\n    g: Math.round((g3bit / 7) * 255),\n    b: Math.round((b3bit / 7) * 255)\n  };\n};\n\n/**\n * Calculate color distance using weighted Euclidean distance\n */\nconst colorDistance = (c1: Color, c2: Color): number => {\n  // Use weighted RGB distance for better perceptual accuracy\n  const rWeight = 0.3;\n  const gWeight = 0.59;\n  const bWeight = 0.11;\n  \n  const deltaR = c1.r - c2.r;\n  const deltaG = c1.g - c2.g;\n  const deltaB = c1.b - c2.b;\n  \n  return Math.sqrt(\n    rWeight * deltaR * deltaR +\n    gWeight * deltaG * deltaG +\n    bWeight * deltaB * deltaB\n  );\n};\n\n/**\n * Median cut algorithm for color quantization\n */\nexport const medianCutQuantization = (colors: Color[], targetCount: number): Color[] => {\n  if (colors.length <= targetCount) {\n    return colors;\n  }\n  \n  // Sort by most frequent colors first\n  colors.sort((a, b) => (b.count || 0) - (a.count || 0));\n  \n  const buckets: Color[][] = [colors];\n  \n  while (buckets.length < targetCount) {\n    // Find the bucket with the largest range\n    let largestBucket = 0;\n    let largestRange = 0;\n    \n    for (let i = 0; i < buckets.length; i++) {\n      const bucket = buckets[i];\n      if (bucket.length <= 1) continue;\n      \n      const rRange = Math.max(...bucket.map(c => c.r)) - Math.min(...bucket.map(c => c.r));\n      const gRange = Math.max(...bucket.map(c => c.g)) - Math.min(...bucket.map(c => c.g));\n      const bRange = Math.max(...bucket.map(c => c.b)) - Math.min(...bucket.map(c => c.b));\n      \n      const range = Math.max(rRange, gRange, bRange);\n      if (range > largestRange) {\n        largestRange = range;\n        largestBucket = i;\n      }\n    }\n    \n    if (largestRange === 0) break;\n    \n    const bucket = buckets[largestBucket];\n    \n    // Determine which channel has the largest range\n    const rRange = Math.max(...bucket.map(c => c.r)) - Math.min(...bucket.map(c => c.r));\n    const gRange = Math.max(...bucket.map(c => c.g)) - Math.min(...bucket.map(c => c.g));\n    const bRange = Math.max(...bucket.map(c => c.b)) - Math.min(...bucket.map(c => c.b));\n    \n    let sortKey: keyof Color;\n    if (rRange >= gRange && rRange >= bRange) {\n      sortKey = 'r';\n    } else if (gRange >= bRange) {\n      sortKey = 'g';\n    } else {\n      sortKey = 'b';\n    }\n    \n    // Sort by the channel with largest range\n    bucket.sort((a, b) => (a[sortKey] as number) - (b[sortKey] as number));\n    \n    // Split at median\n    const median = Math.floor(bucket.length / 2);\n    const bucket1 = bucket.slice(0, median);\n    const bucket2 = bucket.slice(median);\n    \n    buckets[largestBucket] = bucket1;\n    buckets.push(bucket2);\n  }\n  \n  // Calculate average color for each bucket\n  return buckets.map(bucket => {\n    const totalCount = bucket.reduce((sum, c) => sum + (c.count || 1), 0);\n    const avgR = bucket.reduce((sum, c) => sum + c.r * (c.count || 1), 0) / totalCount;\n    const avgG = bucket.reduce((sum, c) => sum + c.g * (c.count || 1), 0) / totalCount;\n    const avgB = bucket.reduce((sum, c) => sum + c.b * (c.count || 1), 0) / totalCount;\n    \n    return {\n      r: Math.round(avgR),\n      g: Math.round(avgG),\n      b: Math.round(avgB),\n      count: totalCount\n    };\n  });\n};\n\n/**\n * Extract unique colors from image data\n */\nexport const extractColorsFromImageData = (imageData: ImageData): Color[] => {\n  const colorMap = new Map<string, number>();\n  const data = imageData.data;\n  \n  for (let i = 0; i < data.length; i += 4) {\n    const r = data[i];\n    const g = data[i + 1];\n    const b = data[i + 2];\n    const a = data[i + 3];\n    \n    if (a > 0) { // Only include non-transparent pixels\n      const key = `${r},${g},${b}`;\n      colorMap.set(key, (colorMap.get(key) || 0) + 1);\n    }\n  }\n  \n  return Array.from(colorMap.entries()).map(([key, count]) => {\n    const [r, g, b] = key.split(',').map(Number);\n    return { r, g, b, count };\n  });\n};\n\n/**\n * Apply quantized palette to image data\n */\nexport const applyQuantizedPalette = (imageData: ImageData, palette: Color[]): ImageData => {\n  const data = imageData.data;\n  const newImageData = new ImageData(new Uint8ClampedArray(data), imageData.width, imageData.height);\n  const newData = newImageData.data;\n  \n  for (let i = 0; i < data.length; i += 4) {\n    const r = data[i];\n    const g = data[i + 1];\n    const b = data[i + 2];\n    const a = data[i + 3];\n    \n    if (a > 0) {\n      // Find closest color in palette\n      let closestColor = palette[0];\n      let minDistance = Infinity;\n      \n      for (const color of palette) {\n        const distance = colorDistance({ r, g, b }, color);\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestColor = color;\n        }\n      }\n      \n      newData[i] = closestColor.r;\n      newData[i + 1] = closestColor.g;\n      newData[i + 2] = closestColor.b;\n      newData[i + 3] = a;\n    } else {\n      newData[i] = r;\n      newData[i + 1] = g;\n      newData[i + 2] = b;\n      newData[i + 3] = a;\n    }\n  }\n  \n  return newImageData;\n};\n\n/**\n * Process image for Mega Drive format:\n * 1. Convert to RGB 3-3-3 format\n * 2. Preserve original palette if image has 16 or fewer colors\n * 3. Quantize to 16 colors only if needed\n * 4. Return processed image data and palette\n */\nexport const processMegaDriveImage = (imageData: ImageData, originalPalette?: Color[]): { imageData: ImageData; palette: Color[] } => {\n  // Step 1: Extract original colors from the image\n  const originalColors = extractColorsFromImageData(imageData);\n  \n  // Step 2: Convert all colors to RGB 3-3-3 format\n  const rgb333ImageData = new ImageData(\n    new Uint8ClampedArray(imageData.data),\n    imageData.width,\n    imageData.height\n  );\n  \n  const data = rgb333ImageData.data;\n  for (let i = 0; i < data.length; i += 4) {\n    if (data[i + 3] > 0) { // Only process non-transparent pixels\n      const rgb333 = toRGB333(data[i], data[i + 1], data[i + 2]);\n      data[i] = rgb333.r;\n      data[i + 1] = rgb333.g;\n      data[i + 2] = rgb333.b;\n    }\n  }\n  \n  // Step 3: Extract unique colors from RGB 3-3-3 converted image\n  const uniqueColors = extractColorsFromImageData(rgb333ImageData);\n  \n  // Step 4: Determine final palette - always quantize to exactly 16 most representative colors\n  let finalPalette: Color[];\n  \n  if (uniqueColors.length <= 16) {\n    // Use the RGB 3-3-3 converted colors as-is if 16 or fewer\n    finalPalette = uniqueColors;\n  } else {\n    // Always quantize to 16 colors using median cut for images with more than 16 colors\n    finalPalette = medianCutQuantization(uniqueColors, 16);\n  }\n  \n  // Ensure all palette colors are snapped to RGB 3-3-3 grid\n  finalPalette = finalPalette.map(color => toRGB333(color.r, color.g, color.b));\n\n  // Ensure exactly 16 colors for Mega Drive - pad with transparent black if needed\n  while (finalPalette.length < 16) {\n    finalPalette.push({ r: 0, g: 0, b: 0, count: 0 });\n  }\n  \n  // Limit to exactly 16 colors\n  finalPalette = finalPalette.slice(0, 16);\n  \n  // Step 5: Apply final palette to image\n  const finalImageData = applyQuantizedPalette(rgb333ImageData, finalPalette);\n  \n  return {\n    imageData: finalImageData,\n    palette: finalPalette\n  };\n};","// Web Worker for CPU-intensive image processing operations\n// This offloads heavy computations from the main thread to prevent UI freezing\n\nimport { extractColorsFromImageData, medianCutQuantization, applyQuantizedPalette, toRGB333, Color } from '../lib/colorQuantization';\n\nexport type ProcessingMessageType =\n  | 'PROCESS_IMAGE'\n  | 'QUANTIZE_COLORS'\n  | 'APPLY_PALETTE'\n  | 'EXTRACT_COLORS'\n  | 'MEGA_DRIVE_PROCESS';\n\nexport interface ProcessingMessage {\n  type: ProcessingMessageType;\n  data: Record<string, unknown> | null;\n  id: string;\n}\n\nexport type ProcessingResponseType = 'PROCESSING_COMPLETE' | 'PROCESSING_ERROR' | 'PROCESSING_PROGRESS';\n\nexport interface ProcessingResponse {\n  type: ProcessingResponseType;\n  data: unknown;\n  id: string;\n  progress?: number;\n}\n\n// Helper to transfer ImageData to worker\nconst processImageData = (imageData: ImageData, operation: string, options: Record<string, unknown> = {}) => {\n    switch (operation) {\n      case 'EXTRACT_COLORS':\n        return extractColorsFromImageData(imageData);\n        \n      case 'QUANTIZE_COLORS':\n        {\n          const { colors, targetCount } = options as { colors?: Color[]; targetCount?: number };\n          return medianCutQuantization(colors || [], targetCount || 16);\n        }\n        \n      case 'APPLY_PALETTE':\n        {\n          const { palette } = options as { palette?: Color[] };\n          return applyQuantizedPalette(imageData, palette || []);\n        }\n        \n      case 'MEGA_DRIVE_PROCESS': {\n        const { originalPalette } = options as { originalPalette?: Color[] };\n        return processMegaDriveInWorker(imageData, originalPalette as unknown as RGBColor[]);\n      }\n    }\n};\n\n// Optimized Mega Drive processing in worker\ntype RGBColor = { r: number; g: number; b: number; count?: number };\n\nconst processMegaDriveInWorker = (imageData: ImageData, originalPalette?: RGBColor[]) => {\n  // Step 1: Extract original colors\n  const originalColors = extractColorsFromImageData(imageData);\n  \n  // Step 2: Convert to RGB 3-3-3 format with progress tracking\n  const rgb333ImageData = new ImageData(\n    new Uint8ClampedArray(imageData.data),\n    imageData.width,\n    imageData.height\n  );\n  \n  const data = rgb333ImageData.data;\n  const totalPixels = data.length / 4;\n  \n  for (let i = 0; i < data.length; i += 4) {\n    if (data[i + 3] > 0) { // Only process non-transparent pixels\n      const rgb333 = toRGB333(data[i], data[i + 1], data[i + 2]);\n      data[i] = rgb333.r;\n      data[i + 1] = rgb333.g;\n      data[i + 2] = rgb333.b;\n    }\n    \n    // Send progress updates for large images\n    // Send progress updates every 10% of pixels processed (use integer math)\n    const progressStep = Math.max(1, Math.floor(totalPixels / 10));\n    if (i > 0 && ((i / 4) % progressStep) === 0) {\n      const percent = Math.floor(((i / 4) / totalPixels) * 50); // First 50% is RGB conversion\n      self.postMessage({\n        type: 'PROCESSING_PROGRESS',\n        progress: percent,\n        id: 'current'\n      } as ProcessingResponse);\n    }\n  }\n  \n  // Step 3: Extract unique colors from converted image\n  const uniqueColors = extractColorsFromImageData(rgb333ImageData);\n  \n  // Step 4: Quantize if needed\n  let finalPalette;\n  if (uniqueColors.length <= 16) {\n    finalPalette = uniqueColors;\n  } else {\n    finalPalette = medianCutQuantization(uniqueColors, 16);\n  }\n  \n  // Ensure all palette colors are RGB 3-3-3\n  // Ensure each palette entry conforms to RGBColor then convert to 3-3-3\n  finalPalette = finalPalette.map((c) => {\n    const color = c as Partial<RGBColor>;\n    const r = typeof color.r === 'number' ? color.r : 0;\n    const g = typeof color.g === 'number' ? color.g : 0;\n    const b = typeof color.b === 'number' ? color.b : 0;\n    return toRGB333(r, g, b);\n  });\n  \n  // Pad to exactly 16 colors\n  while (finalPalette.length < 16) {\n    finalPalette.push({ r: 0, g: 0, b: 0, count: 0 });\n  }\n  finalPalette = finalPalette.slice(0, 16);\n  \n  // Step 5: Apply final palette\n  const finalImageData = applyQuantizedPalette(rgb333ImageData, finalPalette);\n  \n  return {\n    imageData: finalImageData,\n    palette: finalPalette\n  };\n};\n\n// Process chunked image data for large images\nconst processInChunks = (imageData: ImageData, operation: string, options: Record<string, unknown>, chunkSize = 1024) => {\n  const { width, height, data } = imageData;\n  const chunks = [];\n  \n  // Divide image into horizontal strips\n  const stripHeight = Math.floor(chunkSize / width) || 1;\n  \n  for (let y = 0; y < height; y += stripHeight) {\n    const actualStripHeight = Math.min(stripHeight, height - y);\n    const stripData = new Uint8ClampedArray(width * actualStripHeight * 4);\n    \n    // Copy strip data\n    for (let row = 0; row < actualStripHeight; row++) {\n      const sourceStart = ((y + row) * width) * 4;\n      const sourceEnd = sourceStart + (width * 4);\n      const targetStart = row * width * 4;\n      \n      stripData.set(data.subarray(sourceStart, sourceEnd), targetStart);\n    }\n    \n    chunks.push({\n      imageData: new ImageData(stripData, width, actualStripHeight),\n      yOffset: y\n    });\n  }\n  \n  return chunks;\n};\n\n// Handle messages from main thread\nself.addEventListener('message', (event: MessageEvent<ProcessingMessage>) => {\n  const { type, data, id } = event.data;\n\n  try {\n    let result: unknown;\n\n    // payload may be null if sender didn't include data\n    const payload = data || {};\n\n    switch (type) {\n      case 'PROCESS_IMAGE': {\n        const imageData = payload.imageData as ImageData | undefined;\n        const operation = typeof payload.operation === 'string' ? payload.operation : '';\n        const options = (payload.options as Record<string, unknown>) || {};\n        if (!imageData) throw new Error('Missing imageData for PROCESS_IMAGE');\n        result = processImageData(imageData, operation, options);\n        break;\n      }\n\n      case 'QUANTIZE_COLORS': {\n        const colors = Array.isArray(payload.colors) ? (payload.colors as Color[]) : [];\n        const targetCount = typeof payload.targetCount === 'number' ? payload.targetCount : Number(payload.targetCount) || 16;\n        result = medianCutQuantization(colors, targetCount);\n        break;\n      }\n\n      case 'APPLY_PALETTE': {\n        const imageData = payload.imageData as ImageData | undefined;\n        const palette = Array.isArray(payload.palette) ? (payload.palette as Color[]) : [];\n        if (!imageData) throw new Error('Missing imageData for APPLY_PALETTE');\n        result = applyQuantizedPalette(imageData, palette);\n        break;\n      }\n\n      case 'EXTRACT_COLORS': {\n        const imageData = payload.imageData as ImageData | undefined;\n        if (!imageData) throw new Error('Missing imageData for EXTRACT_COLORS');\n        result = extractColorsFromImageData(imageData);\n        break;\n      }\n\n      case 'MEGA_DRIVE_PROCESS': {\n        const imageData = payload.imageData as ImageData | undefined;\n        const rawPalette = Array.isArray(payload.originalPalette) ? (payload.originalPalette as Color[]) : undefined;\n        const originalPalette = rawPalette ? rawPalette.map(c => ({ r: c.r, g: c.g, b: c.b })) : undefined;\n        if (!imageData) throw new Error('Missing imageData for MEGA_DRIVE_PROCESS');\n        result = processMegaDriveInWorker(imageData, originalPalette);\n        break;\n      }\n\n      default:\n        throw new Error(`Unknown message type: ${type}`);\n    }\n\n    // Send result back to main thread\n    const response: ProcessingResponse = {\n      type: 'PROCESSING_COMPLETE',\n      data: result,\n      id\n    };\n\n    self.postMessage(response);\n\n  } catch (error) {\n    // Send error back to main thread (stringify non-Error values)\n    const errPayload = error instanceof Error ? { message: error.message, stack: error.stack } : { message: String(error) };\n    const response: ProcessingResponse = {\n      type: 'PROCESSING_ERROR',\n      data: errPayload,\n      id\n    };\n    self.postMessage(response);\n  }\n});\n\n// Keep TypeScript happy in worker context\nexport {};\n"],"names":["toRGB333","r","b","r3bit","g3bit","b3bit","colorDistance","c1","c2","deltaR","deltaG","deltaB","medianCutQuantization","colors","targetCount","a","buckets","largestBucket","largestRange","i","bucket","rRange","c","gRange","bRange","range","sortKey","median","bucket1","bucket2","totalCount","sum","avgR","avgG","avgB","extractColorsFromImageData","imageData","colorMap","data","g","key","count","applyQuantizedPalette","palette","newImageData","newData","closestColor","minDistance","color","distance","processImageData","operation","options","originalPalette","processMegaDriveInWorker","rgb333ImageData","totalPixels","rgb333","progressStep","percent","uniqueColors","finalPalette","event","type","id","result","payload","rawPalette","response","error"],"mappings":"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"}