{"version":3,"file":"image-processing-DfJTan-A.js","sources":["../../src/lib/pngIndexedEncoder.ts","../../src/lib/pngAnalyzer.ts"],"sourcesContent":["// PNG-8 Indexed Format Encoder\n// Creates proper indexed PNG files with palette chunks\n\ninterface Color {\n  r: number;\n  g: number;\n  b: number;\n  a?: number;\n}\n\nclass PNGIndexedEncoder {\n  private buffer: Uint8Array;\n  private position: number;\n\n  constructor() {\n    this.buffer = new Uint8Array(0);\n    this.position = 0;\n  }\n\n  private crc32(data: Uint8Array): number {\n    let crc = -1;\n    for (let i = 0; i < data.length; i++) {\n      crc = (crc >>> 8) ^ this.crc32Table[(crc ^ data[i]) & 0xFF];\n    }\n    return crc ^ -1;\n  }\n\n  private readonly crc32Table = (() => {\n    const table = new Uint32Array(256);\n    for (let i = 0; i < 256; i++) {\n      let c = i;\n      for (let j = 0; j < 8; j++) {\n        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);\n      }\n      table[i] = c;\n    }\n    return table;\n  })();\n\n  private writeBytes(data: Uint8Array): void {\n    const newBuffer = new Uint8Array(this.buffer.length + data.length);\n    newBuffer.set(this.buffer);\n    newBuffer.set(data, this.buffer.length);\n    this.buffer = newBuffer;\n    this.position += data.length;\n  }\n\n  private writeUint32BE(value: number): void {\n    const bytes = new Uint8Array(4);\n    bytes[0] = (value >>> 24) & 0xFF;\n    bytes[1] = (value >>> 16) & 0xFF;\n    bytes[2] = (value >>> 8) & 0xFF;\n    bytes[3] = value & 0xFF;\n    this.writeBytes(bytes);\n  }\n\n  private writeChunk(type: string, data: Uint8Array): void {\n    this.writeUint32BE(data.length);\n    const typeBytes = new TextEncoder().encode(type);\n    this.writeBytes(typeBytes);\n    this.writeBytes(data);\n    \n    const chunkData = new Uint8Array(typeBytes.length + data.length);\n    chunkData.set(typeBytes);\n    chunkData.set(data, typeBytes.length);\n    this.writeUint32BE(this.crc32(chunkData));\n  }\n\n  private createIHDRChunk(width: number, height: number): Uint8Array {\n    const ihdr = new Uint8Array(13);\n    const view = new DataView(ihdr.buffer);\n    \n    view.setUint32(0, width, false);     // Width (big-endian)\n    view.setUint32(4, height, false);    // Height (big-endian)\n    ihdr[8] = 8;                         // Bit depth (8 bits per pixel for indexed)\n    ihdr[9] = 3;                         // Color type (3 = indexed color)\n    ihdr[10] = 0;                        // Compression method\n    ihdr[11] = 0;                        // Filter method\n    ihdr[12] = 0;                        // Interlace method\n    \n    return ihdr;\n  }\n\n  private createPLTEChunk(palette: Color[]): Uint8Array {\n    const plte = new Uint8Array(palette.length * 3);\n    for (let i = 0; i < palette.length; i++) {\n      plte[i * 3] = palette[i].r;\n      plte[i * 3 + 1] = palette[i].g;\n      plte[i * 3 + 2] = palette[i].b;\n    }\n    return plte;\n  }\n\n  private createTRNSChunk(palette: Color[]): Uint8Array | null {\n    const transparentIndices = palette.map(color => color.a !== undefined ? color.a : 255);\n    const hasTransparency = transparentIndices.some(alpha => alpha < 255);\n    \n    if (!hasTransparency) return null;\n    \n    return new Uint8Array(transparentIndices);\n  }\n\n  private deflate(data: Uint8Array): Uint8Array {\n    // Simple deflate implementation for uncompressed blocks\n    // In a production environment, you'd want to use a proper deflate library\n    const maxBlockSize = 65535;\n    const blocks: Uint8Array[] = [];\n    let offset = 0;\n\n    while (offset < data.length) {\n      const blockSize = Math.min(maxBlockSize, data.length - offset);\n      const isLastBlock = offset + blockSize >= data.length;\n      \n      const block = new Uint8Array(5 + blockSize);\n      block[0] = isLastBlock ? 1 : 0; // BFINAL and BTYPE\n      block[1] = blockSize & 0xFF;    // LEN low byte\n      block[2] = (blockSize >> 8) & 0xFF; // LEN high byte\n      block[3] = (~blockSize) & 0xFF; // NLEN low byte\n      block[4] = ((~blockSize) >> 8) & 0xFF; // NLEN high byte\n      \n      block.set(data.subarray(offset, offset + blockSize), 5);\n      blocks.push(block);\n      offset += blockSize;\n    }\n\n    const totalLength = blocks.reduce((sum, block) => sum + block.length, 0);\n    const result = new Uint8Array(2 + totalLength + 4); // +2 for zlib header, +4 for adler32\n    \n    // Zlib header\n    result[0] = 0x78; // CMF\n    result[1] = 0x01; // FLG\n    \n    let pos = 2;\n    for (const block of blocks) {\n      result.set(block, pos);\n      pos += block.length;\n    }\n    \n    // Adler-32 checksum\n    let a = 1, b = 0;\n    for (let i = 0; i < data.length; i++) {\n      a = (a + data[i]) % 65521;\n      b = (b + a) % 65521;\n    }\n    const adler32 = (b << 16) | a;\n    \n    result[pos] = (adler32 >>> 24) & 0xFF;\n    result[pos + 1] = (adler32 >>> 16) & 0xFF;\n    result[pos + 2] = (adler32 >>> 8) & 0xFF;\n    result[pos + 3] = adler32 & 0xFF;\n    \n    return result;\n  }\n\n  private createIDATChunk(imageData: ImageData, palette: Color[]): Uint8Array {\n    const { width, height } = imageData;\n    const data = imageData.data;\n    \n    // Create palette lookup map for faster color matching\n    const paletteMap = new Map<string, number>();\n    palette.forEach((color, index) => {\n      const key = `${color.r},${color.g},${color.b}`;\n      paletteMap.set(key, index);\n    });\n    \n    // Convert RGBA data to indexed data with filter bytes\n    const indexedData = new Uint8Array(height * (width + 1)); // +1 for filter byte per row\n    \n    for (let y = 0; y < height; y++) {\n      indexedData[y * (width + 1)] = 0; // Filter type: None\n      \n      for (let x = 0; x < width; x++) {\n        const pixelIndex = (y * width + x) * 4;\n        const r = data[pixelIndex];\n        const g = data[pixelIndex + 1];\n        const b = data[pixelIndex + 2];\n        \n        // Find closest color in palette\n        const colorKey = `${r},${g},${b}`;\n        let paletteIndex = paletteMap.get(colorKey);\n        \n        if (paletteIndex === undefined) {\n          // Find closest color if exact match not found\n          let minDistance = Infinity;\n          paletteIndex = 0;\n          \n          for (let i = 0; i < palette.length; i++) {\n            const pr = palette[i].r;\n            const pg = palette[i].g;\n            const pb = palette[i].b;\n            const distance = Math.sqrt((r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2);\n            \n            if (distance < minDistance) {\n              minDistance = distance;\n              paletteIndex = i;\n            }\n          }\n        }\n        \n        indexedData[y * (width + 1) + x + 1] = paletteIndex;\n      }\n    }\n    \n    return this.deflate(indexedData);\n  }\n\n  public encodePNG8(imageData: ImageData, palette: Color[]): Uint8Array {\n    this.buffer = new Uint8Array(0);\n    this.position = 0;\n    \n    // PNG signature\n    const signature = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);\n    this.writeBytes(signature);\n    \n    // IHDR chunk\n    const ihdr = this.createIHDRChunk(imageData.width, imageData.height);\n    this.writeChunk('IHDR', ihdr);\n    \n    // PLTE chunk\n    const plte = this.createPLTEChunk(palette);\n    this.writeChunk('PLTE', plte);\n    \n    // tRNS chunk (if transparency is present)\n    const trns = this.createTRNSChunk(palette);\n    if (trns) {\n      this.writeChunk('tRNS', trns);\n    }\n    \n    // IDAT chunk\n    const idat = this.createIDATChunk(imageData, palette);\n    this.writeChunk('IDAT', idat);\n    \n    // IEND chunk\n    this.writeChunk('IEND', new Uint8Array(0));\n    \n    return this.buffer;\n  }\n}\n\nexport function createPNG8IndexedBlob(imageData: ImageData, palette: Color[]): Blob {\n  const encoder = new PNGIndexedEncoder();\n  const pngData = encoder.encodePNG8(imageData, palette);\n  return new Blob([pngData as BlobPart], { type: 'image/png' });\n}\n\nexport function createPNG8IndexedDataURL(imageData: ImageData, palette: Color[]): string {\n  const blob = createPNG8IndexedBlob(imageData, palette);\n  return URL.createObjectURL(blob);\n}","// PNG file structure analyzer\n// PNG file format: https://www.w3.org/TR/PNG/\n\ninterface PNGChunk {\n  length: number;\n  type: string;\n  data: Uint8Array;\n  crc: number;\n}\n\ninterface PNGInfo {\n  width: number;\n  height: number;\n  bitDepth: number;\n  colorType: number;\n  compression: number;\n  filter: number;\n  interlace: number;\n  palette?: { r: number; g: number; b: number }[];\n  hasTransparency: boolean;\n}\n\nexport interface ImageFormatInfo {\n  format: string;\n  isIndexed: boolean;\n  paletteSize?: number;\n  bitDepth?: number;\n}\n\nconst PNG_SIGNATURE = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);\n\nfunction readUint32BE(data: Uint8Array, offset: number): number {\n  return (data[offset] << 24) | (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3];\n}\n\nfunction arrayBufferFromFile(file: File): Promise<ArrayBuffer> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as ArrayBuffer);\n    reader.onerror = reject;\n    reader.readAsArrayBuffer(file);\n  });\n}\n\nfunction arrayBufferFromDataURL(dataURL: string): ArrayBuffer {\n  const base64 = dataURL.split(',')[1];\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n\nfunction isPNG(data: Uint8Array): boolean {\n  if (data.length < 8) return false;\n  for (let i = 0; i < 8; i++) {\n    if (data[i] !== PNG_SIGNATURE[i]) return false;\n  }\n  return true;\n}\n\nfunction parseChunks(data: Uint8Array): PNGChunk[] {\n  const chunks: PNGChunk[] = [];\n  let offset = 8; // Skip PNG signature\n\n  while (offset < data.length) {\n    if (offset + 8 > data.length) break;\n\n    const length = readUint32BE(data, offset);\n    const type = String.fromCharCode(...data.slice(offset + 4, offset + 8));\n    \n    if (offset + 8 + length + 4 > data.length) break;\n    \n    const chunkData = data.slice(offset + 8, offset + 8 + length);\n    const crc = readUint32BE(data, offset + 8 + length);\n\n    chunks.push({\n      length,\n      type,\n      data: chunkData,\n      crc\n    });\n\n    offset += 8 + length + 4;\n\n    // Stop after critical chunks for performance\n    if (type === 'IEND') break;\n  }\n\n  return chunks;\n}\n\nfunction parseIHDR(data: Uint8Array): Omit<PNGInfo, 'palette' | 'hasTransparency'> {\n  return {\n    width: readUint32BE(data, 0),\n    height: readUint32BE(data, 4),\n    bitDepth: data[8],\n    colorType: data[9],\n    compression: data[10],\n    filter: data[11],\n    interlace: data[12]\n  };\n}\n\nfunction parsePLTE(data: Uint8Array): { r: number; g: number; b: number }[] {\n  const palette: { r: number; g: number; b: number }[] = [];\n  \n  for (let i = 0; i < data.length; i += 3) {\n    if (i + 2 < data.length) {\n      palette.push({\n        r: data[i],\n        g: data[i + 1],\n        b: data[i + 2]\n      });\n    }\n  }\n  \n  return palette;\n}\n\nexport async function analyzePNGFile(source: File | string): Promise<ImageFormatInfo> {\n  try {\n    let arrayBuffer: ArrayBuffer;\n\n    if (typeof source === 'string') {\n      if (source.startsWith('data:image/png')) {\n        arrayBuffer = arrayBufferFromDataURL(source);\n      } else {\n        // For URLs, we can't analyze the raw file, return basic info\n        return { format: 'PNG', isIndexed: false };\n      }\n    } else {\n      // Check if it's actually a PNG file\n      if (!source.type.includes('png')) {\n        return { format: source.type.split('/')[1]?.toUpperCase() || 'Unknown', isIndexed: false };\n      }\n      arrayBuffer = await arrayBufferFromFile(source);\n    }\n\n    const data = new Uint8Array(arrayBuffer);\n    \n    if (!isPNG(data)) {\n      return { format: 'PNG', isIndexed: false };\n    }\n\n    const chunks = parseChunks(data);\n    const ihdrChunk = chunks.find(chunk => chunk.type === 'IHDR');\n    const plteChunk = chunks.find(chunk => chunk.type === 'PLTE');\n    const trnsChunk = chunks.find(chunk => chunk.type === 'tRNS');\n\n    if (!ihdrChunk) {\n      return { format: 'PNG', isIndexed: false };\n    }\n\n    const ihdr = parseIHDR(ihdrChunk.data);\n    const hasTransparency = !!trnsChunk;\n\n    // Color type determines the format:\n    // 0 = Grayscale\n    // 2 = RGB\n    // 3 = Indexed (palette)\n    // 4 = Grayscale + Alpha\n    // 6 = RGB + Alpha\n\n    if (ihdr.colorType === 3 && plteChunk) {\n      // Indexed color mode\n      const palette = parsePLTE(plteChunk.data);\n      const paletteSize = palette.length;\n      \n      // Determine if it's PNG-8 based on palette size and bit depth\n      const isPNG8 = ihdr.bitDepth <= 8 && paletteSize <= 256;\n      \n      return {\n        format: `PNG-${isPNG8 ? '8' : '24'} Indexed (${paletteSize} colors palette)`,\n        isIndexed: true,\n        paletteSize,\n        bitDepth: ihdr.bitDepth\n      };\n    } else {\n      // Non-indexed modes\n      let format = 'PNG-24 RGB';\n      \n      switch (ihdr.colorType) {\n        case 0: // Grayscale\n          format = ihdr.bitDepth <= 8 ? 'PNG-8 Grayscale' : 'PNG-16 Grayscale';\n          break;\n        case 2: // RGB\n          format = 'PNG-24 RGB';\n          break;\n        case 4: // Grayscale + Alpha\n          format = 'PNG-16 Grayscale+Alpha';\n          break;\n        case 6: // RGB + Alpha\n          format = 'PNG-32 RGBA';\n          break;\n      }\n      \n      return {\n        format,\n        isIndexed: false,\n        bitDepth: ihdr.bitDepth\n      };\n    }\n  } catch (error) {\n    console.error('Error analyzing PNG file:', error);\n    return { format: 'PNG', isIndexed: false };\n  }\n}\n\nexport async function extractPNGPalette(source: File | string): Promise<{ r: number; g: number; b: number }[] | null> {\n  try {\n    const info = await analyzePNGFile(source);\n    if (!info.isIndexed) return null;\n\n    let arrayBuffer: ArrayBuffer;\n\n    if (typeof source === 'string') {\n      if (source.startsWith('data:image/png')) {\n        arrayBuffer = arrayBufferFromDataURL(source);\n      } else {\n        return null;\n      }\n    } else {\n      arrayBuffer = await arrayBufferFromFile(source);\n    }\n\n    const data = new Uint8Array(arrayBuffer);\n    const chunks = parseChunks(data);\n    const plteChunk = chunks.find(chunk => chunk.type === 'PLTE');\n\n    if (plteChunk) {\n      return parsePLTE(plteChunk.data);\n    }\n\n    return null;\n  } catch (error) {\n    console.error('Error extracting PNG palette:', error);\n    return null;\n  }\n}"],"names":["PNGIndexedEncoder","data","crc","i","table","c","j","newBuffer","value","bytes","type","typeBytes","chunkData","width","height","ihdr","view","palette","plte","transparentIndices","color","alpha","blocks","offset","blockSize","isLastBlock","block","totalLength","sum","result","pos","a","b","adler32","imageData","paletteMap","index","key","indexedData","y","x","pixelIndex","r","g","colorKey","paletteIndex","minDistance","pr","pg","pb","distance","signature","trns","idat","createPNG8IndexedBlob","pngData","PNG_SIGNATURE","readUint32BE","arrayBufferFromFile","file","resolve","reject","reader","arrayBufferFromDataURL","dataURL","base64","binary","isPNG","parseChunks","chunks","length","parseIHDR","parsePLTE","analyzePNGFile","source","arrayBuffer","ihdrChunk","chunk","plteChunk","trnsChunk","hasTransparency","paletteSize","format","error","extractPNGPalette"],"mappings":"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"}