{"version":3,"file":"image-processing-DfJTan-A.js","sources":["../../src/lib/pngIndexedEncoder.ts","../../src/lib/pngAnalyzer.ts"],"sourcesContent":["// PNG-8 Indexed Format Encoder\r\n// Creates proper indexed PNG files with palette chunks\r\n\r\ninterface Color {\r\n  r: number;\r\n  g: number;\r\n  b: number;\r\n  a?: number;\r\n}\r\n\r\nclass PNGIndexedEncoder {\r\n  private buffer: Uint8Array;\r\n  private position: number;\r\n\r\n  constructor() {\r\n    this.buffer = new Uint8Array(0);\r\n    this.position = 0;\r\n  }\r\n\r\n  private crc32(data: Uint8Array): number {\r\n    let crc = -1;\r\n    for (let i = 0; i < data.length; i++) {\r\n      crc = (crc >>> 8) ^ this.crc32Table[(crc ^ data[i]) & 0xFF];\r\n    }\r\n    return crc ^ -1;\r\n  }\r\n\r\n  private readonly crc32Table = (() => {\r\n    const table = new Uint32Array(256);\r\n    for (let i = 0; i < 256; i++) {\r\n      let c = i;\r\n      for (let j = 0; j < 8; j++) {\r\n        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);\r\n      }\r\n      table[i] = c;\r\n    }\r\n    return table;\r\n  })();\r\n\r\n  private writeBytes(data: Uint8Array): void {\r\n    const newBuffer = new Uint8Array(this.buffer.length + data.length);\r\n    newBuffer.set(this.buffer);\r\n    newBuffer.set(data, this.buffer.length);\r\n    this.buffer = newBuffer;\r\n    this.position += data.length;\r\n  }\r\n\r\n  private writeUint32BE(value: number): void {\r\n    const bytes = new Uint8Array(4);\r\n    bytes[0] = (value >>> 24) & 0xFF;\r\n    bytes[1] = (value >>> 16) & 0xFF;\r\n    bytes[2] = (value >>> 8) & 0xFF;\r\n    bytes[3] = value & 0xFF;\r\n    this.writeBytes(bytes);\r\n  }\r\n\r\n  private writeChunk(type: string, data: Uint8Array): void {\r\n    this.writeUint32BE(data.length);\r\n    const typeBytes = new TextEncoder().encode(type);\r\n    this.writeBytes(typeBytes);\r\n    this.writeBytes(data);\r\n    \r\n    const chunkData = new Uint8Array(typeBytes.length + data.length);\r\n    chunkData.set(typeBytes);\r\n    chunkData.set(data, typeBytes.length);\r\n    this.writeUint32BE(this.crc32(chunkData));\r\n  }\r\n\r\n  private createIHDRChunk(width: number, height: number): Uint8Array {\r\n    const ihdr = new Uint8Array(13);\r\n    const view = new DataView(ihdr.buffer);\r\n    \r\n    view.setUint32(0, width, false);     // Width (big-endian)\r\n    view.setUint32(4, height, false);    // Height (big-endian)\r\n    ihdr[8] = 8;                         // Bit depth (8 bits per pixel for indexed)\r\n    ihdr[9] = 3;                         // Color type (3 = indexed color)\r\n    ihdr[10] = 0;                        // Compression method\r\n    ihdr[11] = 0;                        // Filter method\r\n    ihdr[12] = 0;                        // Interlace method\r\n    \r\n    return ihdr;\r\n  }\r\n\r\n  private createPLTEChunk(palette: Color[]): Uint8Array {\r\n    const plte = new Uint8Array(palette.length * 3);\r\n    for (let i = 0; i < palette.length; i++) {\r\n      plte[i * 3] = palette[i].r;\r\n      plte[i * 3 + 1] = palette[i].g;\r\n      plte[i * 3 + 2] = palette[i].b;\r\n    }\r\n    return plte;\r\n  }\r\n\r\n  private createTRNSChunk(palette: Color[]): Uint8Array | null {\r\n    const transparentIndices = palette.map(color => color.a !== undefined ? color.a : 255);\r\n    const hasTransparency = transparentIndices.some(alpha => alpha < 255);\r\n    \r\n    if (!hasTransparency) return null;\r\n    \r\n    return new Uint8Array(transparentIndices);\r\n  }\r\n\r\n  private deflate(data: Uint8Array): Uint8Array {\r\n    // Simple deflate implementation for uncompressed blocks\r\n    // In a production environment, you'd want to use a proper deflate library\r\n    const maxBlockSize = 65535;\r\n    const blocks: Uint8Array[] = [];\r\n    let offset = 0;\r\n\r\n    while (offset < data.length) {\r\n      const blockSize = Math.min(maxBlockSize, data.length - offset);\r\n      const isLastBlock = offset + blockSize >= data.length;\r\n      \r\n      const block = new Uint8Array(5 + blockSize);\r\n      block[0] = isLastBlock ? 1 : 0; // BFINAL and BTYPE\r\n      block[1] = blockSize & 0xFF;    // LEN low byte\r\n      block[2] = (blockSize >> 8) & 0xFF; // LEN high byte\r\n      block[3] = (~blockSize) & 0xFF; // NLEN low byte\r\n      block[4] = ((~blockSize) >> 8) & 0xFF; // NLEN high byte\r\n      \r\n      block.set(data.subarray(offset, offset + blockSize), 5);\r\n      blocks.push(block);\r\n      offset += blockSize;\r\n    }\r\n\r\n    const totalLength = blocks.reduce((sum, block) => sum + block.length, 0);\r\n    const result = new Uint8Array(2 + totalLength + 4); // +2 for zlib header, +4 for adler32\r\n    \r\n    // Zlib header\r\n    result[0] = 0x78; // CMF\r\n    result[1] = 0x01; // FLG\r\n    \r\n    let pos = 2;\r\n    for (const block of blocks) {\r\n      result.set(block, pos);\r\n      pos += block.length;\r\n    }\r\n    \r\n    // Adler-32 checksum\r\n    let a = 1, b = 0;\r\n    for (let i = 0; i < data.length; i++) {\r\n      a = (a + data[i]) % 65521;\r\n      b = (b + a) % 65521;\r\n    }\r\n    const adler32 = (b << 16) | a;\r\n    \r\n    result[pos] = (adler32 >>> 24) & 0xFF;\r\n    result[pos + 1] = (adler32 >>> 16) & 0xFF;\r\n    result[pos + 2] = (adler32 >>> 8) & 0xFF;\r\n    result[pos + 3] = adler32 & 0xFF;\r\n    \r\n    return result;\r\n  }\r\n\r\n  private createIDATChunk(imageData: ImageData, palette: Color[]): Uint8Array {\r\n    const { width, height } = imageData;\r\n    const data = imageData.data;\r\n    \r\n    // Create palette lookup map for faster color matching\r\n    const paletteMap = new Map<string, number>();\r\n    palette.forEach((color, index) => {\r\n      const key = `${color.r},${color.g},${color.b}`;\r\n      paletteMap.set(key, index);\r\n    });\r\n    \r\n    // Convert RGBA data to indexed data with filter bytes\r\n    const indexedData = new Uint8Array(height * (width + 1)); // +1 for filter byte per row\r\n    \r\n    for (let y = 0; y < height; y++) {\r\n      indexedData[y * (width + 1)] = 0; // Filter type: None\r\n      \r\n      for (let x = 0; x < width; x++) {\r\n        const pixelIndex = (y * width + x) * 4;\r\n        const r = data[pixelIndex];\r\n        const g = data[pixelIndex + 1];\r\n        const b = data[pixelIndex + 2];\r\n        \r\n        // Find closest color in palette\r\n        const colorKey = `${r},${g},${b}`;\r\n        let paletteIndex = paletteMap.get(colorKey);\r\n        \r\n        if (paletteIndex === undefined) {\r\n          // Find closest color if exact match not found\r\n          let minDistance = Infinity;\r\n          paletteIndex = 0;\r\n          \r\n          for (let i = 0; i < palette.length; i++) {\r\n            const pr = palette[i].r;\r\n            const pg = palette[i].g;\r\n            const pb = palette[i].b;\r\n            const distance = Math.sqrt((r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2);\r\n            \r\n            if (distance < minDistance) {\r\n              minDistance = distance;\r\n              paletteIndex = i;\r\n            }\r\n          }\r\n        }\r\n        \r\n        indexedData[y * (width + 1) + x + 1] = paletteIndex;\r\n      }\r\n    }\r\n    \r\n    return this.deflate(indexedData);\r\n  }\r\n\r\n  public encodePNG8(imageData: ImageData, palette: Color[]): Uint8Array {\r\n    this.buffer = new Uint8Array(0);\r\n    this.position = 0;\r\n    \r\n    // PNG signature\r\n    const signature = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);\r\n    this.writeBytes(signature);\r\n    \r\n    // IHDR chunk\r\n    const ihdr = this.createIHDRChunk(imageData.width, imageData.height);\r\n    this.writeChunk('IHDR', ihdr);\r\n    \r\n    // PLTE chunk\r\n    const plte = this.createPLTEChunk(palette);\r\n    this.writeChunk('PLTE', plte);\r\n    \r\n    // tRNS chunk (if transparency is present)\r\n    const trns = this.createTRNSChunk(palette);\r\n    if (trns) {\r\n      this.writeChunk('tRNS', trns);\r\n    }\r\n    \r\n    // IDAT chunk\r\n    const idat = this.createIDATChunk(imageData, palette);\r\n    this.writeChunk('IDAT', idat);\r\n    \r\n    // IEND chunk\r\n    this.writeChunk('IEND', new Uint8Array(0));\r\n    \r\n    return this.buffer;\r\n  }\r\n}\r\n\r\nexport function createPNG8IndexedBlob(imageData: ImageData, palette: Color[]): Blob {\r\n  const encoder = new PNGIndexedEncoder();\r\n  const pngData = encoder.encodePNG8(imageData, palette);\r\n  return new Blob([pngData as BlobPart], { type: 'image/png' });\r\n}\r\n\r\nexport function createPNG8IndexedDataURL(imageData: ImageData, palette: Color[]): string {\r\n  const blob = createPNG8IndexedBlob(imageData, palette);\r\n  return URL.createObjectURL(blob);\r\n}","// PNG file structure analyzer\r\n// PNG file format: https://www.w3.org/TR/PNG/\r\n\r\ninterface PNGChunk {\r\n  length: number;\r\n  type: string;\r\n  data: Uint8Array;\r\n  crc: number;\r\n}\r\n\r\ninterface PNGInfo {\r\n  width: number;\r\n  height: number;\r\n  bitDepth: number;\r\n  colorType: number;\r\n  compression: number;\r\n  filter: number;\r\n  interlace: number;\r\n  palette?: { r: number; g: number; b: number }[];\r\n  hasTransparency: boolean;\r\n}\r\n\r\nexport interface ImageFormatInfo {\r\n  format: string;\r\n  isIndexed: boolean;\r\n  paletteSize?: number;\r\n  bitDepth?: number;\r\n}\r\n\r\nconst PNG_SIGNATURE = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);\r\n\r\nfunction readUint32BE(data: Uint8Array, offset: number): number {\r\n  return (data[offset] << 24) | (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3];\r\n}\r\n\r\nfunction arrayBufferFromFile(file: File): Promise<ArrayBuffer> {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    reader.onload = () => resolve(reader.result as ArrayBuffer);\r\n    reader.onerror = reject;\r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n}\r\n\r\nfunction arrayBufferFromDataURL(dataURL: string): ArrayBuffer {\r\n  const base64 = dataURL.split(',')[1];\r\n  const binary = atob(base64);\r\n  const bytes = new Uint8Array(binary.length);\r\n  for (let i = 0; i < binary.length; i++) {\r\n    bytes[i] = binary.charCodeAt(i);\r\n  }\r\n  return bytes.buffer;\r\n}\r\n\r\nfunction isPNG(data: Uint8Array): boolean {\r\n  if (data.length < 8) return false;\r\n  for (let i = 0; i < 8; i++) {\r\n    if (data[i] !== PNG_SIGNATURE[i]) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction parseChunks(data: Uint8Array): PNGChunk[] {\r\n  const chunks: PNGChunk[] = [];\r\n  let offset = 8; // Skip PNG signature\r\n\r\n  while (offset < data.length) {\r\n    if (offset + 8 > data.length) break;\r\n\r\n    const length = readUint32BE(data, offset);\r\n    const type = String.fromCharCode(...data.slice(offset + 4, offset + 8));\r\n    \r\n    if (offset + 8 + length + 4 > data.length) break;\r\n    \r\n    const chunkData = data.slice(offset + 8, offset + 8 + length);\r\n    const crc = readUint32BE(data, offset + 8 + length);\r\n\r\n    chunks.push({\r\n      length,\r\n      type,\r\n      data: chunkData,\r\n      crc\r\n    });\r\n\r\n    offset += 8 + length + 4;\r\n\r\n    // Stop after critical chunks for performance\r\n    if (type === 'IEND') break;\r\n  }\r\n\r\n  return chunks;\r\n}\r\n\r\nfunction parseIHDR(data: Uint8Array): Omit<PNGInfo, 'palette' | 'hasTransparency'> {\r\n  return {\r\n    width: readUint32BE(data, 0),\r\n    height: readUint32BE(data, 4),\r\n    bitDepth: data[8],\r\n    colorType: data[9],\r\n    compression: data[10],\r\n    filter: data[11],\r\n    interlace: data[12]\r\n  };\r\n}\r\n\r\nfunction parsePLTE(data: Uint8Array): { r: number; g: number; b: number }[] {\r\n  const palette: { r: number; g: number; b: number }[] = [];\r\n  \r\n  for (let i = 0; i < data.length; i += 3) {\r\n    if (i + 2 < data.length) {\r\n      palette.push({\r\n        r: data[i],\r\n        g: data[i + 1],\r\n        b: data[i + 2]\r\n      });\r\n    }\r\n  }\r\n  \r\n  return palette;\r\n}\r\n\r\nexport async function analyzePNGFile(source: File | string): Promise<ImageFormatInfo> {\r\n  try {\r\n    let arrayBuffer: ArrayBuffer;\r\n\r\n    if (typeof source === 'string') {\r\n      if (source.startsWith('data:image/png')) {\r\n        arrayBuffer = arrayBufferFromDataURL(source);\r\n      } else {\r\n        // For URLs, we can't analyze the raw file, return basic info\r\n        return { format: 'PNG', isIndexed: false };\r\n      }\r\n    } else {\r\n      // Check if it's actually a PNG file\r\n      if (!source.type.includes('png')) {\r\n        return { format: source.type.split('/')[1]?.toUpperCase() || 'Unknown', isIndexed: false };\r\n      }\r\n      arrayBuffer = await arrayBufferFromFile(source);\r\n    }\r\n\r\n    const data = new Uint8Array(arrayBuffer);\r\n    \r\n    if (!isPNG(data)) {\r\n      return { format: 'PNG', isIndexed: false };\r\n    }\r\n\r\n    const chunks = parseChunks(data);\r\n    const ihdrChunk = chunks.find(chunk => chunk.type === 'IHDR');\r\n    const plteChunk = chunks.find(chunk => chunk.type === 'PLTE');\r\n    const trnsChunk = chunks.find(chunk => chunk.type === 'tRNS');\r\n\r\n    if (!ihdrChunk) {\r\n      return { format: 'PNG', isIndexed: false };\r\n    }\r\n\r\n    const ihdr = parseIHDR(ihdrChunk.data);\r\n    const hasTransparency = !!trnsChunk;\r\n\r\n    // Color type determines the format:\r\n    // 0 = Grayscale\r\n    // 2 = RGB\r\n    // 3 = Indexed (palette)\r\n    // 4 = Grayscale + Alpha\r\n    // 6 = RGB + Alpha\r\n\r\n    if (ihdr.colorType === 3 && plteChunk) {\r\n      // Indexed color mode\r\n      const palette = parsePLTE(plteChunk.data);\r\n      const paletteSize = palette.length;\r\n      \r\n      // Determine if it's PNG-8 based on palette size and bit depth\r\n      const isPNG8 = ihdr.bitDepth <= 8 && paletteSize <= 256;\r\n      \r\n      return {\r\n        format: `PNG-${isPNG8 ? '8' : '24'} Indexed (${paletteSize} colors palette)`,\r\n        isIndexed: true,\r\n        paletteSize,\r\n        bitDepth: ihdr.bitDepth\r\n      };\r\n    } else {\r\n      // Non-indexed modes\r\n      let format = 'PNG-24 RGB';\r\n      \r\n      switch (ihdr.colorType) {\r\n        case 0: // Grayscale\r\n          format = ihdr.bitDepth <= 8 ? 'PNG-8 Grayscale' : 'PNG-16 Grayscale';\r\n          break;\r\n        case 2: // RGB\r\n          format = 'PNG-24 RGB';\r\n          break;\r\n        case 4: // Grayscale + Alpha\r\n          format = 'PNG-16 Grayscale+Alpha';\r\n          break;\r\n        case 6: // RGB + Alpha\r\n          format = 'PNG-32 RGBA';\r\n          break;\r\n      }\r\n      \r\n      return {\r\n        format,\r\n        isIndexed: false,\r\n        bitDepth: ihdr.bitDepth\r\n      };\r\n    }\r\n  } catch (error) {\r\n    console.error('Error analyzing PNG file:', error);\r\n    return { format: 'PNG', isIndexed: false };\r\n  }\r\n}\r\n\r\nexport async function extractPNGPalette(source: File | string): Promise<{ r: number; g: number; b: number }[] | null> {\r\n  try {\r\n    const info = await analyzePNGFile(source);\r\n    if (!info.isIndexed) return null;\r\n\r\n    let arrayBuffer: ArrayBuffer;\r\n\r\n    if (typeof source === 'string') {\r\n      if (source.startsWith('data:image/png')) {\r\n        arrayBuffer = arrayBufferFromDataURL(source);\r\n      } else {\r\n        return null;\r\n      }\r\n    } else {\r\n      arrayBuffer = await arrayBufferFromFile(source);\r\n    }\r\n\r\n    const data = new Uint8Array(arrayBuffer);\r\n    const chunks = parseChunks(data);\r\n    const plteChunk = chunks.find(chunk => chunk.type === 'PLTE');\r\n\r\n    if (plteChunk) {\r\n      return parsePLTE(plteChunk.data);\r\n    }\r\n\r\n    return null;\r\n  } catch (error) {\r\n    console.error('Error extracting PNG palette:', error);\r\n    return null;\r\n  }\r\n}"],"names":["PNGIndexedEncoder","data","crc","i","table","c","j","newBuffer","value","bytes","type","typeBytes","chunkData","width","height","ihdr","view","palette","plte","transparentIndices","color","alpha","blocks","offset","blockSize","isLastBlock","block","totalLength","sum","result","pos","a","b","adler32","imageData","paletteMap","index","key","indexedData","y","x","pixelIndex","r","g","colorKey","paletteIndex","minDistance","pr","pg","pb","distance","signature","trns","idat","createPNG8IndexedBlob","pngData","PNG_SIGNATURE","readUint32BE","arrayBufferFromFile","file","resolve","reject","reader","arrayBufferFromDataURL","dataURL","base64","binary","isPNG","parseChunks","chunks","length","parseIHDR","parsePLTE","analyzePNGFile","source","arrayBuffer","ihdrChunk","chunk","plteChunk","trnsChunk","hasTransparency","paletteSize","format","error","extractPNGPalette"],"mappings":"AAUA,MAAMA,CAAkB,CACd,OACA,SAER,aAAc,CACZ,KAAK,OAAS,IAAI,WAAW,CAAC,EAC9B,KAAK,SAAW,CAClB,CAEQ,MAAMC,EAA0B,CACtC,IAAIC,EAAM,GACV,QAASC,EAAI,EAAGA,EAAIF,EAAK,OAAQE,IAC/BD,EAAOA,IAAQ,EAAK,KAAK,YAAYA,EAAMD,EAAKE,CAAC,GAAK,GAAI,EAE5D,OAAOD,EAAM,EACf,CAEiB,YAAc,IAAM,CACnC,MAAME,EAAQ,IAAI,YAAY,GAAG,EACjC,QAASD,EAAI,EAAGA,EAAI,IAAKA,IAAK,CAC5B,IAAIE,EAAIF,EACR,QAASG,EAAI,EAAGA,EAAI,EAAGA,IACrBD,EAAKA,EAAI,EAAM,WAAcA,IAAM,EAAOA,IAAM,EAElDD,EAAMD,CAAC,EAAIE,CACb,CACA,OAAOD,CACT,GAAA,EAEQ,WAAWH,EAAwB,CACzC,MAAMM,EAAY,IAAI,WAAW,KAAK,OAAO,OAASN,EAAK,MAAM,EACjEM,EAAU,IAAI,KAAK,MAAM,EACzBA,EAAU,IAAIN,EAAM,KAAK,OAAO,MAAM,EACtC,KAAK,OAASM,EACd,KAAK,UAAYN,EAAK,MACxB,CAEQ,cAAcO,EAAqB,CACzC,MAAMC,EAAQ,IAAI,WAAW,CAAC,EAC9BA,EAAM,CAAC,EAAKD,IAAU,GAAM,IAC5BC,EAAM,CAAC,EAAKD,IAAU,GAAM,IAC5BC,EAAM,CAAC,EAAKD,IAAU,EAAK,IAC3BC,EAAM,CAAC,EAAID,EAAQ,IACnB,KAAK,WAAWC,CAAK,CACvB,CAEQ,WAAWC,EAAcT,EAAwB,CACvD,KAAK,cAAcA,EAAK,MAAM,EAC9B,MAAMU,EAAY,IAAI,cAAc,OAAOD,CAAI,EAC/C,KAAK,WAAWC,CAAS,EACzB,KAAK,WAAWV,CAAI,EAEpB,MAAMW,EAAY,IAAI,WAAWD,EAAU,OAASV,EAAK,MAAM,EAC/DW,EAAU,IAAID,CAAS,EACvBC,EAAU,IAAIX,EAAMU,EAAU,MAAM,EACpC,KAAK,cAAc,KAAK,MAAMC,CAAS,CAAC,CAC1C,CAEQ,gBAAgBC,EAAeC,EAA4B,CACjE,MAAMC,EAAO,IAAI,WAAW,EAAE,EACxBC,EAAO,IAAI,SAASD,EAAK,MAAM,EAErC,OAAAC,EAAK,UAAU,EAAGH,EAAO,EAAK,EAC9BG,EAAK,UAAU,EAAGF,EAAQ,EAAK,EAC/BC,EAAK,CAAC,EAAI,EACVA,EAAK,CAAC,EAAI,EACVA,EAAK,EAAE,EAAI,EACXA,EAAK,EAAE,EAAI,EACXA,EAAK,EAAE,EAAI,EAEJA,CACT,CAEQ,gBAAgBE,EAA8B,CACpD,MAAMC,EAAO,IAAI,WAAWD,EAAQ,OAAS,CAAC,EAC9C,QAASd,EAAI,EAAGA,EAAIc,EAAQ,OAAQd,IAClCe,EAAKf,EAAI,CAAC,EAAIc,EAAQd,CAAC,EAAE,EACzBe,EAAKf,EAAI,EAAI,CAAC,EAAIc,EAAQd,CAAC,EAAE,EAC7Be,EAAKf,EAAI,EAAI,CAAC,EAAIc,EAAQd,CAAC,EAAE,EAE/B,OAAOe,CACT,CAEQ,gBAAgBD,EAAqC,CAC3D,MAAME,EAAqBF,EAAQ,IAAIG,GAASA,EAAM,IAAM,OAAYA,EAAM,EAAI,GAAG,EAGrF,OAFwBD,EAAmB,KAAKE,GAASA,EAAQ,GAAG,EAI7D,IAAI,WAAWF,CAAkB,EAFX,IAG/B,CAEQ,QAAQlB,EAA8B,CAI5C,MAAMqB,EAAuB,CAAA,EAC7B,IAAIC,EAAS,EAEb,KAAOA,EAAStB,EAAK,QAAQ,CAC3B,MAAMuB,EAAY,KAAK,IAAI,MAAcvB,EAAK,OAASsB,CAAM,EACvDE,EAAcF,EAASC,GAAavB,EAAK,OAEzCyB,EAAQ,IAAI,WAAW,EAAIF,CAAS,EAC1CE,EAAM,CAAC,EAAID,EAAc,EAAI,EAC7BC,EAAM,CAAC,EAAIF,EAAY,IACvBE,EAAM,CAAC,EAAKF,GAAa,EAAK,IAC9BE,EAAM,CAAC,EAAK,CAACF,EAAa,IAC1BE,EAAM,CAAC,EAAM,CAACF,GAAc,EAAK,IAEjCE,EAAM,IAAIzB,EAAK,SAASsB,EAAQA,EAASC,CAAS,EAAG,CAAC,EACtDF,EAAO,KAAKI,CAAK,EACjBH,GAAUC,CACZ,CAEA,MAAMG,EAAcL,EAAO,OAAO,CAACM,EAAKF,IAAUE,EAAMF,EAAM,OAAQ,CAAC,EACjEG,EAAS,IAAI,WAAW,EAAIF,EAAc,CAAC,EAGjDE,EAAO,CAAC,EAAI,IACZA,EAAO,CAAC,EAAI,EAEZ,IAAIC,EAAM,EACV,UAAWJ,KAASJ,EAClBO,EAAO,IAAIH,EAAOI,CAAG,EACrBA,GAAOJ,EAAM,OAIf,IAAIK,EAAI,EAAGC,EAAI,EACf,QAAS7B,EAAI,EAAGA,EAAIF,EAAK,OAAQE,IAC/B4B,GAAKA,EAAI9B,EAAKE,CAAC,GAAK,MACpB6B,GAAKA,EAAID,GAAK,MAEhB,MAAME,EAAWD,GAAK,GAAMD,EAE5B,OAAAF,EAAOC,CAAG,EAAKG,IAAY,GAAM,IACjCJ,EAAOC,EAAM,CAAC,EAAKG,IAAY,GAAM,IACrCJ,EAAOC,EAAM,CAAC,EAAKG,IAAY,EAAK,IACpCJ,EAAOC,EAAM,CAAC,EAAIG,EAAU,IAErBJ,CACT,CAEQ,gBAAgBK,EAAsBjB,EAA8B,CAC1E,KAAM,CAAE,MAAAJ,EAAO,OAAAC,CAAA,EAAWoB,EACpBjC,EAAOiC,EAAU,KAGjBC,MAAiB,IACvBlB,EAAQ,QAAQ,CAACG,EAAOgB,IAAU,CAChC,MAAMC,EAAM,GAAGjB,EAAM,CAAC,IAAIA,EAAM,CAAC,IAAIA,EAAM,CAAC,GAC5Ce,EAAW,IAAIE,EAAKD,CAAK,CAC3B,CAAC,EAGD,MAAME,EAAc,IAAI,WAAWxB,GAAUD,EAAQ,EAAE,EAEvD,QAAS0B,EAAI,EAAGA,EAAIzB,EAAQyB,IAAK,CAC/BD,EAAYC,GAAK1B,EAAQ,EAAE,EAAI,EAE/B,QAAS2B,EAAI,EAAGA,EAAI3B,EAAO2B,IAAK,CAC9B,MAAMC,GAAcF,EAAI1B,EAAQ2B,GAAK,EAC/BE,EAAIzC,EAAKwC,CAAU,EACnBE,EAAI1C,EAAKwC,EAAa,CAAC,EACvBT,EAAI/B,EAAKwC,EAAa,CAAC,EAGvBG,EAAW,GAAGF,CAAC,IAAIC,CAAC,IAAIX,CAAC,GAC/B,IAAIa,EAAeV,EAAW,IAAIS,CAAQ,EAE1C,GAAIC,IAAiB,OAAW,CAE9B,IAAIC,EAAc,IAClBD,EAAe,EAEf,QAAS1C,EAAI,EAAGA,EAAIc,EAAQ,OAAQd,IAAK,CACvC,MAAM4C,EAAK9B,EAAQd,CAAC,EAAE,EAChB6C,EAAK/B,EAAQd,CAAC,EAAE,EAChB8C,EAAKhC,EAAQd,CAAC,EAAE,EAChB+C,EAAW,KAAK,MAAMR,EAAIK,IAAO,GAAKJ,EAAIK,IAAO,GAAKhB,EAAIiB,IAAO,CAAC,EAEpEC,EAAWJ,IACbA,EAAcI,EACdL,EAAe1C,EAEnB,CACF,CAEAmC,EAAYC,GAAK1B,EAAQ,GAAK2B,EAAI,CAAC,EAAIK,CACzC,CACF,CAEA,OAAO,KAAK,QAAQP,CAAW,CACjC,CAEO,WAAWJ,EAAsBjB,EAA8B,CACpE,KAAK,OAAS,IAAI,WAAW,CAAC,EAC9B,KAAK,SAAW,EAGhB,MAAMkC,EAAY,IAAI,WAAW,CAAC,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAE,CAAC,EAClE,KAAK,WAAWA,CAAS,EAGzB,MAAMpC,EAAO,KAAK,gBAAgBmB,EAAU,MAAOA,EAAU,MAAM,EACnE,KAAK,WAAW,OAAQnB,CAAI,EAG5B,MAAMG,EAAO,KAAK,gBAAgBD,CAAO,EACzC,KAAK,WAAW,OAAQC,CAAI,EAG5B,MAAMkC,EAAO,KAAK,gBAAgBnC,CAAO,EACrCmC,GACF,KAAK,WAAW,OAAQA,CAAI,EAI9B,MAAMC,EAAO,KAAK,gBAAgBnB,EAAWjB,CAAO,EACpD,YAAK,WAAW,OAAQoC,CAAI,EAG5B,KAAK,WAAW,OAAQ,IAAI,WAAW,CAAC,CAAC,EAElC,KAAK,MACd,CACF,CAEO,SAASC,EAAsBpB,EAAsBjB,EAAwB,CAElF,MAAMsC,EADU,IAAIvD,EAAA,EACI,WAAWkC,EAAWjB,CAAO,EACrD,OAAO,IAAI,KAAK,CAACsC,CAAmB,EAAG,CAAE,KAAM,YAAa,CAC9D,CCtNA,MAAMC,EAAgB,IAAI,WAAW,CAAC,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAE,CAAC,EAEtE,SAASC,EAAaxD,EAAkBsB,EAAwB,CAC9D,OAAQtB,EAAKsB,CAAM,GAAK,GAAOtB,EAAKsB,EAAS,CAAC,GAAK,GAAOtB,EAAKsB,EAAS,CAAC,GAAK,EAAKtB,EAAKsB,EAAS,CAAC,CACpG,CAEA,SAASmC,EAAoBC,EAAkC,CAC7D,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,MAAMC,EAAS,IAAI,WACnBA,EAAO,OAAS,IAAMF,EAAQE,EAAO,MAAqB,EAC1DA,EAAO,QAAUD,EACjBC,EAAO,kBAAkBH,CAAI,CAC/B,CAAC,CACH,CAEA,SAASI,EAAuBC,EAA8B,CAC5D,MAAMC,EAASD,EAAQ,MAAM,GAAG,EAAE,CAAC,EAC7BE,EAAS,KAAKD,CAAM,EACpBxD,EAAQ,IAAI,WAAWyD,EAAO,MAAM,EAC1C,QAAS/D,EAAI,EAAGA,EAAI+D,EAAO,OAAQ/D,IACjCM,EAAMN,CAAC,EAAI+D,EAAO,WAAW/D,CAAC,EAEhC,OAAOM,EAAM,MACf,CAEA,SAAS0D,EAAMlE,EAA2B,CACxC,GAAIA,EAAK,OAAS,EAAG,MAAO,GAC5B,QAASE,EAAI,EAAGA,EAAI,EAAGA,IACrB,GAAIF,EAAKE,CAAC,IAAMqD,EAAcrD,CAAC,EAAG,MAAO,GAE3C,MAAO,EACT,CAEA,SAASiE,EAAYnE,EAA8B,CACjD,MAAMoE,EAAqB,CAAA,EAC3B,IAAI9C,EAAS,EAEb,KAAOA,EAAStB,EAAK,QACf,EAAAsB,EAAS,EAAItB,EAAK,SADK,CAG3B,MAAMqE,EAASb,EAAaxD,EAAMsB,CAAM,EAClCb,EAAO,OAAO,aAAa,GAAGT,EAAK,MAAMsB,EAAS,EAAGA,EAAS,CAAC,CAAC,EAEtE,GAAIA,EAAS,EAAI+C,EAAS,EAAIrE,EAAK,OAAQ,MAE3C,MAAMW,EAAYX,EAAK,MAAMsB,EAAS,EAAGA,EAAS,EAAI+C,CAAM,EACtDpE,EAAMuD,EAAaxD,EAAMsB,EAAS,EAAI+C,CAAM,EAYlD,GAVAD,EAAO,KAAK,CACV,OAAAC,EACA,KAAA5D,EACA,KAAME,EACN,IAAAV,CAAA,CACD,EAEDqB,GAAU,EAAI+C,EAAS,EAGnB5D,IAAS,OAAQ,KACvB,CAEA,OAAO2D,CACT,CAEA,SAASE,EAAUtE,EAAgE,CACjF,MAAO,CACL,MAAOwD,EAAaxD,EAAM,CAAC,EAC3B,OAAQwD,EAAaxD,EAAM,CAAC,EAC5B,SAAUA,EAAK,CAAC,EAChB,UAAWA,EAAK,CAAC,EACjB,YAAaA,EAAK,EAAE,EACpB,OAAQA,EAAK,EAAE,EACf,UAAWA,EAAK,EAAE,CAAA,CAEtB,CAEA,SAASuE,EAAUvE,EAAyD,CAC1E,MAAMgB,EAAiD,CAAA,EAEvD,QAASd,EAAI,EAAGA,EAAIF,EAAK,OAAQE,GAAK,EAChCA,EAAI,EAAIF,EAAK,QACfgB,EAAQ,KAAK,CACX,EAAGhB,EAAKE,CAAC,EACT,EAAGF,EAAKE,EAAI,CAAC,EACb,EAAGF,EAAKE,EAAI,CAAC,CAAA,CACd,EAIL,OAAOc,CACT,CAEA,eAAsBwD,EAAeC,EAAiD,CACpF,GAAI,CACF,IAAIC,EAEJ,GAAI,OAAOD,GAAW,SACpB,GAAIA,EAAO,WAAW,gBAAgB,EACpCC,EAAcZ,EAAuBW,CAAM,MAG3C,OAAO,CAAE,OAAQ,MAAO,UAAW,EAAA,MAEhC,CAEL,GAAI,CAACA,EAAO,KAAK,SAAS,KAAK,EAC7B,MAAO,CAAE,OAAQA,EAAO,KAAK,MAAM,GAAG,EAAE,CAAC,GAAG,YAAA,GAAiB,UAAW,UAAW,EAAA,EAErFC,EAAc,MAAMjB,EAAoBgB,CAAM,CAChD,CAEA,MAAMzE,EAAO,IAAI,WAAW0E,CAAW,EAEvC,GAAI,CAACR,EAAMlE,CAAI,EACb,MAAO,CAAE,OAAQ,MAAO,UAAW,EAAA,EAGrC,MAAMoE,EAASD,EAAYnE,CAAI,EACzB2E,EAAYP,EAAO,KAAKQ,GAASA,EAAM,OAAS,MAAM,EACtDC,EAAYT,EAAO,KAAKQ,GAASA,EAAM,OAAS,MAAM,EACtDE,EAAYV,EAAO,KAAKQ,GAASA,EAAM,OAAS,MAAM,EAE5D,GAAI,CAACD,EACH,MAAO,CAAE,OAAQ,MAAO,UAAW,EAAA,EAGrC,MAAM7D,EAAOwD,EAAUK,EAAU,IAAI,EAC/BI,EAAkB,CAAC,CAACD,EAS1B,GAAIhE,EAAK,YAAc,GAAK+D,EAAW,CAGrC,MAAMG,EADUT,EAAUM,EAAU,IAAI,EACZ,OAK5B,MAAO,CACL,OAAQ,OAHK/D,EAAK,UAAY,GAAKkE,GAAe,IAG1B,IAAM,IAAI,aAAaA,CAAW,mBAC1D,UAAW,GACX,YAAAA,EACA,SAAUlE,EAAK,QAAA,CAEnB,KAAO,CAEL,IAAImE,EAAS,aAEb,OAAQnE,EAAK,UAAA,CACX,IAAK,GACHmE,EAASnE,EAAK,UAAY,EAAI,kBAAoB,mBAClD,MACF,IAAK,GACHmE,EAAS,aACT,MACF,IAAK,GACHA,EAAS,yBACT,MACF,IAAK,GACHA,EAAS,cACT,KAAA,CAGJ,MAAO,CACL,OAAAA,EACA,UAAW,GACX,SAAUnE,EAAK,QAAA,CAEnB,CACF,OAASoE,EAAO,CACd,eAAQ,MAAM,4BAA6BA,CAAK,EACzC,CAAE,OAAQ,MAAO,UAAW,EAAA,CACrC,CACF,CAEA,eAAsBC,EAAkBV,EAA8E,CACpH,GAAI,CAEF,GAAI,EADS,MAAMD,EAAeC,CAAM,GAC9B,UAAW,OAAO,KAE5B,IAAIC,EAEJ,GAAI,OAAOD,GAAW,SACpB,GAAIA,EAAO,WAAW,gBAAgB,EACpCC,EAAcZ,EAAuBW,CAAM,MAE3C,QAAO,UAGTC,EAAc,MAAMjB,EAAoBgB,CAAM,EAGhD,MAAMzE,EAAO,IAAI,WAAW0E,CAAW,EAEjCG,EADSV,EAAYnE,CAAI,EACN,KAAK4E,GAASA,EAAM,OAAS,MAAM,EAE5D,OAAIC,EACKN,EAAUM,EAAU,IAAI,EAG1B,IACT,OAASK,EAAO,CACd,eAAQ,MAAM,gCAAiCA,CAAK,EAC7C,IACT,CACF"}