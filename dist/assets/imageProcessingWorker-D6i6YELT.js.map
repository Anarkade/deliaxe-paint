{"version":3,"file":"imageProcessingWorker-D6i6YELT.js","sources":["../src/lib/colorQuantization.ts","../src/workers/imageProcessingWorker.ts"],"sourcesContent":["// Color quantization utilities for retro palette conversion\r\n\r\nexport interface Color {\r\n  r: number;\r\n  g: number;\r\n  b: number;\r\n  count?: number;\r\n}\r\n\r\n/**\r\n * Convert RGB color to RGB 3-3-3 format (Mega Drive format)\r\n */\r\nexport const toRGB333 = (r: number, g: number, b: number): Color => {\r\n  // Convert 8-bit values to 3-bit values\r\n  const r3bit = Math.round((r / 255) * 7);\r\n  const g3bit = Math.round((g / 255) * 7);\r\n  const b3bit = Math.round((b / 255) * 7);\r\n  \r\n  // Convert back to 8-bit values for display\r\n  return {\r\n    r: Math.round((r3bit / 7) * 255),\r\n    g: Math.round((g3bit / 7) * 255),\r\n    b: Math.round((b3bit / 7) * 255)\r\n  };\r\n};\r\n\r\n/**\r\n * Calculate color distance using weighted Euclidean distance\r\n */\r\nconst colorDistance = (c1: Color, c2: Color): number => {\r\n  // Use weighted RGB distance for better perceptual accuracy\r\n  const rWeight = 0.3;\r\n  const gWeight = 0.59;\r\n  const bWeight = 0.11;\r\n  \r\n  const deltaR = c1.r - c2.r;\r\n  const deltaG = c1.g - c2.g;\r\n  const deltaB = c1.b - c2.b;\r\n  \r\n  return Math.sqrt(\r\n    rWeight * deltaR * deltaR +\r\n    gWeight * deltaG * deltaG +\r\n    bWeight * deltaB * deltaB\r\n  );\r\n};\r\n\r\n/**\r\n * Median cut algorithm for color quantization\r\n */\r\nexport const medianCutQuantization = (colors: Color[], targetCount: number): Color[] => {\r\n  if (colors.length <= targetCount) {\r\n    return colors;\r\n  }\r\n  \r\n  // Sort by most frequent colors first\r\n  colors.sort((a, b) => (b.count || 0) - (a.count || 0));\r\n  \r\n  const buckets: Color[][] = [colors];\r\n  \r\n  while (buckets.length < targetCount) {\r\n    // Find the bucket with the largest range\r\n    let largestBucket = 0;\r\n    let largestRange = 0;\r\n    \r\n    for (let i = 0; i < buckets.length; i++) {\r\n      const bucket = buckets[i];\r\n      if (bucket.length <= 1) continue;\r\n      \r\n      const rRange = Math.max(...bucket.map(c => c.r)) - Math.min(...bucket.map(c => c.r));\r\n      const gRange = Math.max(...bucket.map(c => c.g)) - Math.min(...bucket.map(c => c.g));\r\n      const bRange = Math.max(...bucket.map(c => c.b)) - Math.min(...bucket.map(c => c.b));\r\n      \r\n      const range = Math.max(rRange, gRange, bRange);\r\n      if (range > largestRange) {\r\n        largestRange = range;\r\n        largestBucket = i;\r\n      }\r\n    }\r\n    \r\n    if (largestRange === 0) break;\r\n    \r\n    const bucket = buckets[largestBucket];\r\n    \r\n    // Determine which channel has the largest range\r\n    const rRange = Math.max(...bucket.map(c => c.r)) - Math.min(...bucket.map(c => c.r));\r\n    const gRange = Math.max(...bucket.map(c => c.g)) - Math.min(...bucket.map(c => c.g));\r\n    const bRange = Math.max(...bucket.map(c => c.b)) - Math.min(...bucket.map(c => c.b));\r\n    \r\n    let sortKey: keyof Color;\r\n    if (rRange >= gRange && rRange >= bRange) {\r\n      sortKey = 'r';\r\n    } else if (gRange >= bRange) {\r\n      sortKey = 'g';\r\n    } else {\r\n      sortKey = 'b';\r\n    }\r\n    \r\n    // Sort by the channel with largest range\r\n    bucket.sort((a, b) => (a[sortKey] as number) - (b[sortKey] as number));\r\n    \r\n    // Split at median\r\n    const median = Math.floor(bucket.length / 2);\r\n    const bucket1 = bucket.slice(0, median);\r\n    const bucket2 = bucket.slice(median);\r\n    \r\n    buckets[largestBucket] = bucket1;\r\n    buckets.push(bucket2);\r\n  }\r\n  \r\n  // Calculate average color for each bucket\r\n  return buckets.map(bucket => {\r\n    const totalCount = bucket.reduce((sum, c) => sum + (c.count || 1), 0);\r\n    const avgR = bucket.reduce((sum, c) => sum + c.r * (c.count || 1), 0) / totalCount;\r\n    const avgG = bucket.reduce((sum, c) => sum + c.g * (c.count || 1), 0) / totalCount;\r\n    const avgB = bucket.reduce((sum, c) => sum + c.b * (c.count || 1), 0) / totalCount;\r\n    \r\n    return {\r\n      r: Math.round(avgR),\r\n      g: Math.round(avgG),\r\n      b: Math.round(avgB),\r\n      count: totalCount\r\n    };\r\n  });\r\n};\r\n\r\n/**\r\n * Extract unique colors from image data\r\n */\r\nexport const extractColorsFromImageData = (imageData: ImageData): Color[] => {\r\n  const colorMap = new Map<string, number>();\r\n  const data = imageData.data;\r\n  \r\n  for (let i = 0; i < data.length; i += 4) {\r\n    const r = data[i];\r\n    const g = data[i + 1];\r\n    const b = data[i + 2];\r\n    const a = data[i + 3];\r\n    \r\n    if (a > 0) { // Only include non-transparent pixels\r\n      const key = `${r},${g},${b}`;\r\n      colorMap.set(key, (colorMap.get(key) || 0) + 1);\r\n    }\r\n  }\r\n  \r\n  return Array.from(colorMap.entries()).map(([key, count]) => {\r\n    const [r, g, b] = key.split(',').map(Number);\r\n    return { r, g, b, count };\r\n  });\r\n};\r\n\r\n/**\r\n * Apply quantized palette to image data\r\n */\r\nexport const applyQuantizedPalette = (imageData: ImageData, palette: Color[]): ImageData => {\r\n  const data = imageData.data;\r\n  const newImageData = new ImageData(new Uint8ClampedArray(data), imageData.width, imageData.height);\r\n  const newData = newImageData.data;\r\n  \r\n  for (let i = 0; i < data.length; i += 4) {\r\n    const r = data[i];\r\n    const g = data[i + 1];\r\n    const b = data[i + 2];\r\n    const a = data[i + 3];\r\n    \r\n    if (a > 0) {\r\n      // Find closest color in palette\r\n      let closestColor = palette[0];\r\n      let minDistance = Infinity;\r\n      \r\n      for (const color of palette) {\r\n        const distance = colorDistance({ r, g, b }, color);\r\n        if (distance < minDistance) {\r\n          minDistance = distance;\r\n          closestColor = color;\r\n        }\r\n      }\r\n      \r\n      newData[i] = closestColor.r;\r\n      newData[i + 1] = closestColor.g;\r\n      newData[i + 2] = closestColor.b;\r\n      newData[i + 3] = a;\r\n    } else {\r\n      newData[i] = r;\r\n      newData[i + 1] = g;\r\n      newData[i + 2] = b;\r\n      newData[i + 3] = a;\r\n    }\r\n  }\r\n  \r\n  return newImageData;\r\n};\r\n\r\n/**\r\n * Process image for Mega Drive format:\r\n * 1. Convert to RGB 3-3-3 format\r\n * 2. Preserve original palette if image has 16 or fewer colors\r\n * 3. Quantize to 16 colors only if needed\r\n * 4. Return processed image data and palette\r\n */\r\nexport const processMegaDriveImage = (imageData: ImageData, originalPalette?: Color[]): { imageData: ImageData; palette: Color[] } => {\r\n  // Step 1: Extract original colors from the image\r\n  const originalColors = extractColorsFromImageData(imageData);\r\n  \r\n  // Step 2: Convert all colors to RGB 3-3-3 format\r\n  const rgb333ImageData = new ImageData(\r\n    new Uint8ClampedArray(imageData.data),\r\n    imageData.width,\r\n    imageData.height\r\n  );\r\n  \r\n  const data = rgb333ImageData.data;\r\n  for (let i = 0; i < data.length; i += 4) {\r\n    if (data[i + 3] > 0) { // Only process non-transparent pixels\r\n      const rgb333 = toRGB333(data[i], data[i + 1], data[i + 2]);\r\n      data[i] = rgb333.r;\r\n      data[i + 1] = rgb333.g;\r\n      data[i + 2] = rgb333.b;\r\n    }\r\n  }\r\n  \r\n  // Step 3: Extract unique colors from RGB 3-3-3 converted image\r\n  const uniqueColors = extractColorsFromImageData(rgb333ImageData);\r\n  \r\n  // Step 4: Determine final palette - always quantize to exactly 16 most representative colors\r\n  let finalPalette: Color[];\r\n  \r\n  if (uniqueColors.length <= 16) {\r\n    // Use the RGB 3-3-3 converted colors as-is if 16 or fewer\r\n    finalPalette = uniqueColors;\r\n  } else {\r\n    // Always quantize to 16 colors using median cut for images with more than 16 colors\r\n    finalPalette = medianCutQuantization(uniqueColors, 16);\r\n  }\r\n  \r\n  // Ensure all palette colors are snapped to RGB 3-3-3 grid\r\n  finalPalette = finalPalette.map(color => toRGB333(color.r, color.g, color.b));\r\n\r\n  // Ensure exactly 16 colors for Mega Drive - pad with transparent black if needed\r\n  while (finalPalette.length < 16) {\r\n    finalPalette.push({ r: 0, g: 0, b: 0, count: 0 });\r\n  }\r\n  \r\n  // Limit to exactly 16 colors\r\n  finalPalette = finalPalette.slice(0, 16);\r\n  \r\n  // Step 5: Apply final palette to image\r\n  const finalImageData = applyQuantizedPalette(rgb333ImageData, finalPalette);\r\n  \r\n  return {\r\n    imageData: finalImageData,\r\n    palette: finalPalette\r\n  };\r\n};","// Web Worker for CPU-intensive image processing operations\r\n// This offloads heavy computations from the main thread to prevent UI freezing\r\n\r\nimport { extractColorsFromImageData, medianCutQuantization, applyQuantizedPalette, toRGB333, Color } from '../lib/colorQuantization';\r\n\r\nexport type ProcessingMessageType =\r\n  | 'PROCESS_IMAGE'\r\n  | 'QUANTIZE_COLORS'\r\n  | 'APPLY_PALETTE'\r\n  | 'EXTRACT_COLORS'\r\n  | 'MEGA_DRIVE_PROCESS';\r\n\r\nexport interface ProcessingMessage {\r\n  type: ProcessingMessageType;\r\n  data: Record<string, unknown> | null;\r\n  id: string;\r\n}\r\n\r\nexport type ProcessingResponseType = 'PROCESSING_COMPLETE' | 'PROCESSING_ERROR' | 'PROCESSING_PROGRESS';\r\n\r\nexport interface ProcessingResponse {\r\n  type: ProcessingResponseType;\r\n  data: unknown;\r\n  id: string;\r\n  progress?: number;\r\n}\r\n\r\n// Helper to transfer ImageData to worker\r\nconst processImageData = (imageData: ImageData, operation: string, options: Record<string, unknown> = {}) => {\r\n    switch (operation) {\r\n      case 'EXTRACT_COLORS':\r\n        return extractColorsFromImageData(imageData);\r\n        \r\n      case 'QUANTIZE_COLORS':\r\n        {\r\n          const { colors, targetCount } = options as { colors?: Color[]; targetCount?: number };\r\n          return medianCutQuantization(colors || [], targetCount || 16);\r\n        }\r\n        \r\n      case 'APPLY_PALETTE':\r\n        {\r\n          const { palette } = options as { palette?: Color[] };\r\n          return applyQuantizedPalette(imageData, palette || []);\r\n        }\r\n        \r\n      case 'MEGA_DRIVE_PROCESS': {\r\n        const { originalPalette } = options as { originalPalette?: Color[] };\r\n        return processMegaDriveInWorker(imageData, originalPalette as unknown as RGBColor[]);\r\n      }\r\n    }\r\n};\r\n\r\n// Optimized Mega Drive processing in worker\r\ntype RGBColor = { r: number; g: number; b: number; count?: number };\r\n\r\nconst processMegaDriveInWorker = (imageData: ImageData, originalPalette?: RGBColor[]) => {\r\n  // Step 1: Extract original colors\r\n  const originalColors = extractColorsFromImageData(imageData);\r\n  \r\n  // Step 2: Convert to RGB 3-3-3 format with progress tracking\r\n  const rgb333ImageData = new ImageData(\r\n    new Uint8ClampedArray(imageData.data),\r\n    imageData.width,\r\n    imageData.height\r\n  );\r\n  \r\n  const data = rgb333ImageData.data;\r\n  const totalPixels = data.length / 4;\r\n  \r\n  for (let i = 0; i < data.length; i += 4) {\r\n    if (data[i + 3] > 0) { // Only process non-transparent pixels\r\n      const rgb333 = toRGB333(data[i], data[i + 1], data[i + 2]);\r\n      data[i] = rgb333.r;\r\n      data[i + 1] = rgb333.g;\r\n      data[i + 2] = rgb333.b;\r\n    }\r\n    \r\n    // Send progress updates for large images\r\n    // Send progress updates every 10% of pixels processed (use integer math)\r\n    const progressStep = Math.max(1, Math.floor(totalPixels / 10));\r\n    if (i > 0 && ((i / 4) % progressStep) === 0) {\r\n      const percent = Math.floor(((i / 4) / totalPixels) * 50); // First 50% is RGB conversion\r\n      self.postMessage({\r\n        type: 'PROCESSING_PROGRESS',\r\n        progress: percent,\r\n        id: 'current'\r\n      } as ProcessingResponse);\r\n    }\r\n  }\r\n  \r\n  // Step 3: Extract unique colors from converted image\r\n  const uniqueColors = extractColorsFromImageData(rgb333ImageData);\r\n  \r\n  // Step 4: Quantize if needed\r\n  let finalPalette;\r\n  if (uniqueColors.length <= 16) {\r\n    finalPalette = uniqueColors;\r\n  } else {\r\n    finalPalette = medianCutQuantization(uniqueColors, 16);\r\n  }\r\n  \r\n  // Ensure all palette colors are RGB 3-3-3\r\n  // Ensure each palette entry conforms to RGBColor then convert to 3-3-3\r\n  finalPalette = finalPalette.map((c) => {\r\n    const color = c as Partial<RGBColor>;\r\n    const r = typeof color.r === 'number' ? color.r : 0;\r\n    const g = typeof color.g === 'number' ? color.g : 0;\r\n    const b = typeof color.b === 'number' ? color.b : 0;\r\n    return toRGB333(r, g, b);\r\n  });\r\n  \r\n  // Pad to exactly 16 colors\r\n  while (finalPalette.length < 16) {\r\n    finalPalette.push({ r: 0, g: 0, b: 0, count: 0 });\r\n  }\r\n  finalPalette = finalPalette.slice(0, 16);\r\n  \r\n  // Step 5: Apply final palette\r\n  const finalImageData = applyQuantizedPalette(rgb333ImageData, finalPalette);\r\n  \r\n  return {\r\n    imageData: finalImageData,\r\n    palette: finalPalette\r\n  };\r\n};\r\n\r\n// Process chunked image data for large images\r\nconst processInChunks = (imageData: ImageData, operation: string, options: Record<string, unknown>, chunkSize = 1024) => {\r\n  const { width, height, data } = imageData;\r\n  const chunks = [];\r\n  \r\n  // Divide image into horizontal strips\r\n  const stripHeight = Math.floor(chunkSize / width) || 1;\r\n  \r\n  for (let y = 0; y < height; y += stripHeight) {\r\n    const actualStripHeight = Math.min(stripHeight, height - y);\r\n    const stripData = new Uint8ClampedArray(width * actualStripHeight * 4);\r\n    \r\n    // Copy strip data\r\n    for (let row = 0; row < actualStripHeight; row++) {\r\n      const sourceStart = ((y + row) * width) * 4;\r\n      const sourceEnd = sourceStart + (width * 4);\r\n      const targetStart = row * width * 4;\r\n      \r\n      stripData.set(data.subarray(sourceStart, sourceEnd), targetStart);\r\n    }\r\n    \r\n    chunks.push({\r\n      imageData: new ImageData(stripData, width, actualStripHeight),\r\n      yOffset: y\r\n    });\r\n  }\r\n  \r\n  return chunks;\r\n};\r\n\r\n// Handle messages from main thread\r\nself.addEventListener('message', (event: MessageEvent<ProcessingMessage>) => {\r\n  const { type, data, id } = event.data;\r\n\r\n  try {\r\n    let result: unknown;\r\n\r\n    // payload may be null if sender didn't include data\r\n    const payload = data || {};\r\n\r\n    switch (type) {\r\n      case 'PROCESS_IMAGE': {\r\n        const imageData = payload.imageData as ImageData | undefined;\r\n        const operation = typeof payload.operation === 'string' ? payload.operation : '';\r\n        const options = (payload.options as Record<string, unknown>) || {};\r\n        if (!imageData) throw new Error('Missing imageData for PROCESS_IMAGE');\r\n        result = processImageData(imageData, operation, options);\r\n        break;\r\n      }\r\n\r\n      case 'QUANTIZE_COLORS': {\r\n        const colors = Array.isArray(payload.colors) ? (payload.colors as Color[]) : [];\r\n        const targetCount = typeof payload.targetCount === 'number' ? payload.targetCount : Number(payload.targetCount) || 16;\r\n        result = medianCutQuantization(colors, targetCount);\r\n        break;\r\n      }\r\n\r\n      case 'APPLY_PALETTE': {\r\n        const imageData = payload.imageData as ImageData | undefined;\r\n        const palette = Array.isArray(payload.palette) ? (payload.palette as Color[]) : [];\r\n        if (!imageData) throw new Error('Missing imageData for APPLY_PALETTE');\r\n        result = applyQuantizedPalette(imageData, palette);\r\n        break;\r\n      }\r\n\r\n      case 'EXTRACT_COLORS': {\r\n        const imageData = payload.imageData as ImageData | undefined;\r\n        if (!imageData) throw new Error('Missing imageData for EXTRACT_COLORS');\r\n        result = extractColorsFromImageData(imageData);\r\n        break;\r\n      }\r\n\r\n      case 'MEGA_DRIVE_PROCESS': {\r\n        const imageData = payload.imageData as ImageData | undefined;\r\n        const rawPalette = Array.isArray(payload.originalPalette) ? (payload.originalPalette as Color[]) : undefined;\r\n        const originalPalette = rawPalette ? rawPalette.map(c => ({ r: c.r, g: c.g, b: c.b })) : undefined;\r\n        if (!imageData) throw new Error('Missing imageData for MEGA_DRIVE_PROCESS');\r\n        result = processMegaDriveInWorker(imageData, originalPalette);\r\n        break;\r\n      }\r\n\r\n      default:\r\n        throw new Error(`Unknown message type: ${type}`);\r\n    }\r\n\r\n    // Send result back to main thread\r\n    const response: ProcessingResponse = {\r\n      type: 'PROCESSING_COMPLETE',\r\n      data: result,\r\n      id\r\n    };\r\n\r\n    self.postMessage(response);\r\n\r\n  } catch (error) {\r\n    // Send error back to main thread (stringify non-Error values)\r\n    const errPayload = error instanceof Error ? { message: error.message, stack: error.stack } : { message: String(error) };\r\n    const response: ProcessingResponse = {\r\n      type: 'PROCESSING_ERROR',\r\n      data: errPayload,\r\n      id\r\n    };\r\n    self.postMessage(response);\r\n  }\r\n});\r\n\r\n// Keep TypeScript happy in worker context\r\nexport {};\r\n"],"names":["toRGB333","r","b","r3bit","g3bit","b3bit","colorDistance","c1","c2","deltaR","deltaG","deltaB","medianCutQuantization","colors","targetCount","a","buckets","largestBucket","largestRange","i","bucket","rRange","c","gRange","bRange","range","sortKey","median","bucket1","bucket2","totalCount","sum","avgR","avgG","avgB","extractColorsFromImageData","imageData","colorMap","data","g","key","count","applyQuantizedPalette","palette","newImageData","newData","closestColor","minDistance","color","distance","processImageData","operation","options","originalPalette","processMegaDriveInWorker","rgb333ImageData","totalPixels","rgb333","progressStep","percent","uniqueColors","finalPalette","event","type","id","result","payload","rawPalette","response","error"],"mappings":"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"}